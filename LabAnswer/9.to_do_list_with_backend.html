<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>To-Do List (Backend)</title>
    <style>
        /* ========== 기본 스타일 ========== */
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Segoe UI', sans-serif;
            background: linear-gradient(135deg, #667eea, #764ba2);
            min-height: 100vh;
            padding: 40px 20px;
        }

        /* ========== 컨테이너 ========== */
        .container {
            max-width: 500px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.3);
        }

        /* ========== 타이틀 ========== */
        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 30px;
            font-size: 2rem;
        }

        /* ========== 사용자 입력 영역 ========== */
        .user-area {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        #userInput {
            flex: 1;
            padding: 12px 15px;
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            font-size: 1rem;
            outline: none;
            transition: border-color 0.3s;
        }

        #userInput:focus {
            border-color: #667eea;
        }

        #loginBtn {
            padding: 12px 20px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 1rem;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        #loginBtn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .user-info {
            text-align: center;
            margin-bottom: 15px;
            color: #667eea;
            font-weight: bold;
        }

        /* ========== 입력 영역 ========== */
        .input-area {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        #todoInput {
            flex: 1;
            padding: 15px;
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            font-size: 1rem;
            outline: none;
            transition: border-color 0.3s;
        }

        #todoInput:focus {
            border-color: #667eea;
        }

        #addBtn {
            padding: 15px 25px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 1rem;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        #addBtn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        /* ========== 필터 버튼 ========== */
        .filter-area {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 20px;
        }

        .filter-btn {
            padding: 8px 20px;
            border: 2px solid #e0e0e0;
            background: white;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .filter-btn:hover {
            border-color: #667eea;
        }

        .filter-btn.active {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }

        /* ========== 할 일 목록 ========== */
        #todoList {
            list-style: none;
        }

        .todo-item {
            display: flex;
            align-items: center;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 10px;
            margin-bottom: 10px;
            transition: all 0.3s;
        }

        .todo-item:hover {
            background: #e9ecef;
        }

        .todo-item.completed {
            opacity: 0.6;
        }

        .todo-item.completed .todo-text {
            text-decoration: line-through;
            color: #888;
        }

        /* 체크박스 */
        .todo-checkbox {
            width: 22px;
            height: 22px;
            margin-right: 15px;
            cursor: pointer;
            accent-color: #667eea;
        }

        /* 할 일 텍스트 */
        .todo-text {
            flex: 1;
            font-size: 1rem;
            color: #333;
        }

        /* 삭제 버튼 */
        .delete-btn {
            padding: 8px 15px;
            background: #ff6b6b;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .todo-item:hover .delete-btn {
            opacity: 1;
        }

        .delete-btn:hover {
            background: #ee5a5a;
        }

        /* ========== 통계 영역 ========== */
        .stats {
            text-align: center;
            color: #888;
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid #e0e0e0;
        }

        /* ========== 빈 상태 메시지 ========== */
        .empty-message {
            text-align: center;
            color: #aaa;
            padding: 40px;
            font-size: 1.1rem;
        }

        /* ========== 로딩 ========== */
        .loading {
            text-align: center;
            color: #888;
            padding: 20px;
        }

        /* ========== 숨김 ========== */
        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>To-Do List</h1>

        <!-- 사용자 입력 영역 -->
        <div class="user-area" id="userArea">
            <input type="text" id="userInput" placeholder="사용자 ID를 입력하세요 (예: alice)">
            <button id="loginBtn">접속</button>
        </div>

        <!-- 사용자 정보 (로그인 후 표시) -->
        <div class="user-info hidden" id="userInfo"></div>

        <!-- 입력 영역 -->
        <div class="input-area hidden" id="inputArea">
            <input type="text" id="todoInput" placeholder="할 일을 입력하세요...">
            <button id="addBtn">추가</button>
        </div>

        <!-- 필터 버튼 -->
        <div class="filter-area hidden" id="filterArea">
            <button class="filter-btn active" data-filter="all">전체</button>
            <button class="filter-btn" data-filter="active">진행중</button>
            <button class="filter-btn" data-filter="completed">완료</button>
        </div>

        <!-- 할 일 목록 -->
        <ul id="todoList"></ul>

        <!-- 통계 -->
        <div class="stats hidden" id="stats"></div>
    </div>

    <script>
        // ================================================================
        // todoApp 객체 리터럴 선언
        // ----------------------------------------------------------------
        // 이 앱은 하나의 객체(todoApp) 안에 모든 상태(데이터)와 메서드(동작)를 모아놓은 구조다.
        // 클래스가 아닌 "객체 리터럴" 패턴으로, 싱글톤처럼 하나만 존재한다.
        // ================================================================
        const todoApp = {

            // ── 속성(Properties) : 앱의 "상태"를 저장하는 데이터 ──

            API_BASE: 'http://210.101.236.166/api/todo',
            // → 백엔드 API의 기본 URL. 모든 fetch 요청에서 이 값을 기준으로 경로를 만든다.
            //   예: `${this.API_BASE}/alice/todos` → "http://210.101.236.166/api/todo/alice/todos"

            userId: '',
            // → 현재 로그인한 사용자 ID. login() 에서 설정되고, 이후 모든 API 호출에서 사용된다.

            todos: [],
            // → 서버에서 받아온 할 일 목록 배열. 각 요소는 { id, text, completed } 형태의 객체다.
            //   예: [{ id: 1, text: "공부하기", completed: false }, { id: 2, text: "운동", completed: true }]

            currentFilter: 'all',
            // → 현재 선택된 필터. 'all' | 'active' | 'completed' 중 하나.
            //   render() 할 때 getFilteredTodos()에서 이 값을 보고 어떤 항목을 보여줄지 결정한다.


            // ================================================================
            // init() - 앱 시작점 (Entry Point)
            // ================================================================
            // 호출 흐름: 맨 아래 todoApp.init() → this.bindEvents()
            // 역할: 이벤트 리스너를 등록해서 사용자 입력에 반응할 준비를 한다.
            // ================================================================
            init() {
                this.bindEvents();
                // this === todoApp 객체 자신
                // → todoApp.bindEvents() 를 호출하는 것과 같다
            },


            // ================================================================
            // bindEvents() - 모든 이벤트 리스너 등록
            // ================================================================
            // 호출 흐름: init() → bindEvents()
            // 역할: DOM 요소에 click/keypress 이벤트를 연결한다.
            //
            // 중요 포인트: 화살표 함수(() => {})를 쓰는 이유
            //   - 일반 function을 쓰면 this가 클릭된 DOM 요소를 가리킴
            //   - 화살표 함수를 쓰면 this가 todoApp 객체를 유지함
            //   - 그래서 this.login(), this.addTodo() 등을 안전하게 호출 가능
            // ================================================================
            bindEvents() {

                // ── 1) 접속 버튼 클릭 ──
                document.getElementById('loginBtn').addEventListener('click', () => {
                    this.login();
                    // this === todoApp (화살표 함수이므로 바깥 스코프의 this를 그대로 사용)
                    // → todoApp.login() 호출
                });

                // ── 2) 사용자 ID 입력창에서 Enter 키 ──
                document.getElementById('userInput').addEventListener('keypress', (e) => {
                    // e = KeyboardEvent 객체 (브라우저가 자동으로 넘겨줌)
                    // e.key = 눌린 키의 이름 ('Enter', 'a', 'Shift' 등)
                    if (e.key === 'Enter') {
                        this.login();
                        // Enter 키를 누르면 접속 버튼을 클릭한 것과 동일하게 동작
                    }
                });

                // ── 3) 추가 버튼 클릭 ──
                document.getElementById('addBtn').addEventListener('click', () => {
                    this.addTodo();
                    // → todoApp.addTodo() 호출
                });

                // ── 4) 할 일 입력창에서 Enter 키 ──
                document.getElementById('todoInput').addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        this.addTodo();
                    }
                });

                // ── 5) 필터 버튼 클릭 (이벤트 위임 패턴) ──
                // 이벤트 위임: 개별 버튼마다 리스너를 달지 않고, 부모(.filter-area)에 하나만 달아서
                //              클릭된 자식 요소(e.target)를 확인하는 방식. 효율적이다.
                document.querySelector('.filter-area').addEventListener('click', (e) => {
                    // e.target = 실제로 클릭된 요소 (버튼 중 하나)
                    if (e.target.classList.contains('filter-btn')) {
                        this.setFilter(e.target.dataset.filter);
                        // e.target.dataset.filter → HTML의 data-filter 속성 값
                        // 예: <button data-filter="active"> → e.target.dataset.filter === "active"
                        // → todoApp.setFilter("active") 호출
                    }
                });

                // ── 6) 할 일 목록 클릭 (이벤트 위임 패턴) ──
                // 체크박스 클릭 또는 삭제 버튼 클릭을 하나의 리스너로 처리
                document.getElementById('todoList').addEventListener('click', (e) => {
                    // e.target = 실제 클릭된 요소 (체크박스 or 삭제 버튼 or 텍스트 등)
                    const item = e.target.closest('.todo-item');
                    // closest(): 클릭된 요소부터 위로 올라가며 .todo-item을 찾는다
                    // 예: 삭제 버튼 클릭 → <button>.closest('.todo-item') → 부모 <li> 반환
                    // 예: 빈 영역 클릭 → .todo-item이 없으면 null 반환

                    if (!item) return;
                    // .todo-item 바깥을 클릭했으면 아무 것도 안 함

                    const id = parseInt(item.dataset.id);
                    // item.dataset.id → HTML의 data-id 속성 값 (문자열)
                    // parseInt()로 숫자로 변환. 예: "3" → 3
                    // 이 id는 서버에서 부여한 할 일의 고유 식별자

                    if (e.target.classList.contains('todo-checkbox')) {
                        this.toggleTodo(id);
                        // 체크박스를 클릭한 경우 → 완료/미완료 토글
                        // → todoApp.toggleTodo(3) 같은 형태로 호출
                    } else if (e.target.classList.contains('delete-btn')) {
                        this.deleteTodo(id);
                        // 삭제 버튼을 클릭한 경우 → 해당 할 일 삭제
                    }
                });
            },


            // ================================================================
            // login() - 사용자 접속 처리
            // ================================================================
            // 호출 흐름: 접속 버튼 클릭 → login() → fetchTodos() → render()
            // 역할: 사용자 ID를 저장하고, UI를 전환하고, 서버에서 데이터를 가져온다.
            // ================================================================
            async login() {
                // async: 이 함수 안에서 await를 쓸 수 있게 해준다 (비동기 처리)

                const input = document.getElementById('userInput');
                // → <input id="userInput"> DOM 요소 참조

                const userId = input.value.trim();
                // input.value = 사용자가 입력한 텍스트
                // .trim() = 앞뒤 공백 제거. "  alice  " → "alice"

                if (userId === '') {
                    alert('사용자 ID를 입력해주세요!');
                    return; // 빈 문자열이면 여기서 함수 종료
                }

                this.userId = userId;
                // todoApp.userId에 입력값 저장
                // 이후 API 호출에서 이 값이 URL에 들어간다

                // ── UI 전환: 로그인 폼 숨기고 할 일 영역 표시 ──
                document.getElementById('userArea').classList.add('hidden');
                // → 로그인 입력 영역에 hidden 클래스 추가 (CSS: display: none)

                const userInfo = document.getElementById('userInfo');
                userInfo.textContent = `${this.userId} 님의 할 일 목록`;
                // 템플릿 리터럴: this.userId가 "alice"면 → "alice 님의 할 일 목록"
                userInfo.classList.remove('hidden');
                // → hidden 제거해서 사용자 정보 영역을 보이게 함

                document.getElementById('inputArea').classList.remove('hidden');
                // → 할 일 입력 영역 표시
                document.getElementById('filterArea').classList.remove('hidden');
                // → 필터 버튼 영역 표시
                document.getElementById('stats').classList.remove('hidden');
                // → 통계 영역 표시

                await this.fetchTodos();
                // 서버에서 이 사용자의 할 일 목록을 가져온다
                // await: fetchTodos()가 완료될 때까지 기다린다
                // fetchTodos 안에서 this.todos 배열이 채워지고, render()가 호출된다
            },


            // ================================================================
            // fetchTodos() - 서버에서 할 일 목록 가져오기 (GET 요청)
            // ================================================================
            // 호출 흐름: login() → fetchTodos() → render() → updateStats()
            // HTTP: GET http://210.101.236.166/api/todo/alice/todos
            // 응답 예시: [{ id: 1, text: "공부", completed: false }, ...]
            // ================================================================
            async fetchTodos() {
                try {
                    const response = await fetch(`${this.API_BASE}/${this.userId}/todos`);
                    // fetch() = 브라우저 내장 HTTP 요청 함수
                    // 기본 method는 GET
                    // URL 예: "http://210.101.236.166/api/todo/alice/todos"
                    // await: 서버 응답이 올 때까지 기다린다
                    // response = Response 객체 (상태코드, 헤더, 본문 등 포함)

                    this.todos = await response.json();
                    // response.json() = 응답 본문을 JSON으로 파싱하여 JS 객체/배열로 변환
                    // 반환값: [{ id: 1, text: "공부", completed: false }, ...]
                    // → todoApp.todos 배열에 저장

                    this.render();
                    // 데이터를 받았으니 화면을 다시 그린다
                    // → todoApp.render() 호출

                } catch (error) {
                    // fetch 중 네트워크 에러가 발생하면 여기로 온다
                    console.error('할 일 목록 조회 실패:', error);
                    alert('서버에서 할 일 목록을 불러오지 못했습니다.');
                }
            },


            // ================================================================
            // addTodo() - 새 할 일 추가 (POST 요청)
            // ================================================================
            // 호출 흐름: 추가 버튼 클릭 → addTodo() → 서버 응답 → todos.push() → render()
            // HTTP: POST http://210.101.236.166/api/todo/alice/todos
            // 요청 본문: { "text": "새 할 일" }
            // 응답 예시: { id: 5, text: "새 할 일", completed: false }
            // ================================================================
            async addTodo() {
                const input = document.getElementById('todoInput');
                const text = input.value.trim();

                if (text === '') {
                    alert('할 일을 입력해주세요!');
                    return;
                }

                try {
                    const response = await fetch(`${this.API_BASE}/${this.userId}/todos`, {
                        // 두 번째 인자: 요청 옵션 객체
                        method: 'POST',
                        // HTTP 메서드를 POST로 지정 (기본은 GET)

                        headers: { 'Content-Type': 'application/json' },
                        // 서버에게 "내가 보내는 본문은 JSON 형식이야"라고 알려준다

                        body: JSON.stringify({ text: text })
                        // JSON.stringify(): JS 객체 → JSON 문자열로 변환
                        // { text: "공부하기" } → '{"text":"공부하기"}'
                        // 서버는 이 문자열을 받아서 다시 객체로 파싱한다
                    });

                    const newTodo = await response.json();
                    // 서버가 생성한 할 일 객체를 받는다
                    // 예: { id: 5, text: "공부하기", completed: false }
                    // 서버가 id를 부여해준다 (클라이언트는 id를 만들지 않음)

                    this.todos.push(newTodo);
                    // todoApp.todos 배열 끝에 새 항목 추가
                    // push()는 원본 배열을 직접 수정한다

                    input.value = '';
                    // 입력창 비우기

                    input.focus();
                    // 입력창에 포커스를 다시 줘서 바로 다음 입력 가능

                    this.render();
                    // 화면 다시 그리기

                } catch (error) {
                    console.error('할 일 추가 실패:', error);
                    alert('할 일을 추가하지 못했습니다.');
                }
            },


            // ================================================================
            // toggleTodo(id) - 완료/미완료 상태 토글 (PATCH 요청)
            // ================================================================
            // 호출 흐름: 체크박스 클릭 → toggleTodo(3) → 서버 응답 → todo.completed 갱신 → render()
            // HTTP: PATCH http://210.101.236.166/api/todo/alice/todos/3
            // 요청 본문: { "completed": true }  (현재 false면 true로, true면 false로)
            // 응답 예시: { id: 3, text: "운동", completed: true }
            // ================================================================
            async toggleTodo(id) {
                const todo = this.todos.find(t => t.id === id);
                // .find(): 배열에서 조건에 맞는 첫 번째 요소를 반환
                // t => t.id === id : 각 요소(t)의 id가 매개변수 id와 같은지 확인
                // 예: this.todos = [{id:1,...}, {id:3,...}], id=3 → {id:3,...} 반환
                // 못 찾으면 undefined 반환

                if (!todo) return;
                // 해당 id의 할 일이 없으면 아무것도 안 하고 종료

                try {
                    const response = await fetch(`${this.API_BASE}/${this.userId}/todos/${id}`, {
                        // URL 예: ".../alice/todos/3"
                        method: 'PATCH',
                        // PATCH = 기존 리소스의 일부만 수정할 때 사용하는 HTTP 메서드

                        headers: { 'Content-Type': 'application/json' },

                        body: JSON.stringify({ completed: !todo.completed })
                        // !todo.completed : 현재 값의 반대
                        // false → true (미완료 → 완료)
                        // true → false (완료 → 미완료)
                    });

                    const updated = await response.json();
                    // 서버가 업데이트된 객체를 응답으로 보내준다

                    todo.completed = updated.completed;
                    // find()로 찾은 todo는 this.todos 배열 안의 원본 객체의 참조(reference)다
                    // 그래서 todo.completed를 바꾸면 this.todos 배열 안의 값도 바뀐다
                    // → 새 배열을 만들지 않고도 원본 데이터가 업데이트된다

                    this.render();
                    // 변경된 데이터로 화면 다시 그리기

                } catch (error) {
                    console.error('할 일 수정 실패:', error);
                    alert('할 일 상태를 변경하지 못했습니다.');
                }
            },


            // ================================================================
            // deleteTodo(id) - 할 일 삭제 (DELETE 요청)
            // ================================================================
            // 호출 흐름: 삭제 버튼 클릭 → deleteTodo(3) → 서버 삭제 → todos 배열에서 제거 → render()
            // HTTP: DELETE http://210.101.236.166/api/todo/alice/todos/3
            // 응답: 본문 없이 성공/실패만 반환
            // ================================================================
            async deleteTodo(id) {
                try {
                    await fetch(`${this.API_BASE}/${this.userId}/todos/${id}`, {
                        method: 'DELETE'
                        // DELETE 요청은 본문(body)이 필요 없다
                        // 삭제할 대상은 URL의 id로 식별한다
                    });
                    // 응답 본문을 사용하지 않으므로 response 변수에 저장하지 않음

                    this.todos = this.todos.filter(t => t.id !== id);
                    // .filter(): 조건에 맞는 요소들만 모아서 "새 배열"을 만든다
                    // t.id !== id : id가 다른 것들만 남긴다 = 해당 id를 가진 항목을 제외
                    // 예: [{ id:1 }, { id:3 }, { id:5 }].filter(t => t.id !== 3) → [{ id:1 }, { id:5 }]
                    // push()와 달리 filter()는 새 배열을 반환하므로 this.todos에 재할당한다

                    this.render();

                } catch (error) {
                    console.error('할 일 삭제 실패:', error);
                    alert('할 일을 삭제하지 못했습니다.');
                }
            },


            // ================================================================
            // setFilter(filter) - 필터 상태 변경
            // ================================================================
            // 호출 흐름: 필터 버튼 클릭 → setFilter("active") → render()
            // 역할: currentFilter를 바꾸고, 버튼 활성화 스타일을 업데이트하고, 다시 그린다.
            // ================================================================
            setFilter(filter) {
                this.currentFilter = filter;
                // todoApp.currentFilter를 새 값으로 변경
                // 예: "active", "completed", "all"

                document.querySelectorAll('.filter-btn').forEach(btn => {
                    // querySelectorAll(): 해당 CSS 셀렉터에 맞는 모든 요소를 NodeList로 반환
                    // .forEach(): NodeList의 각 요소(btn)에 대해 콜백 실행

                    btn.classList.toggle('active', btn.dataset.filter === filter);
                    // classList.toggle(클래스명, 조건)
                    //   조건이 true → 클래스 추가
                    //   조건이 false → 클래스 제거
                    // 예: filter가 "active"일 때
                    //   "전체" 버튼: dataset.filter="all" === "active" → false → active 제거
                    //   "진행중" 버튼: dataset.filter="active" === "active" → true → active 추가
                    //   "완료" 버튼: dataset.filter="completed" === "active" → false → active 제거
                });

                this.render();
                // 필터가 바뀌었으니 화면을 다시 그린다
            },


            // ================================================================
            // getFilteredTodos() - 현재 필터에 맞는 할 일 목록 반환
            // ================================================================
            // 호출 흐름: render() → getFilteredTodos() → 필터링된 배열 반환
            // 역할: currentFilter 값에 따라 todos 배열을 필터링해서 반환한다.
            // ================================================================
            getFilteredTodos() {
                switch (this.currentFilter) {
                    case 'active':
                        return this.todos.filter(t => !t.completed);
                        // completed가 false인 것만 = 아직 진행중인 것만 반환
                    case 'completed':
                        return this.todos.filter(t => t.completed);
                        // completed가 true인 것만 = 완료된 것만 반환
                    default:
                        return this.todos;
                        // 'all'이면 전체 배열 그대로 반환 (필터 안 함)
                }
            },


            // ================================================================
            // render() - 화면 그리기 (핵심 렌더링 메서드)
            // ================================================================
            // 호출 흐름: (데이터 변경 후) → render() → getFilteredTodos() + updateStats()
            // 역할: todos 배열의 현재 상태를 HTML로 변환해서 화면에 반영한다.
            // 이 앱에서 데이터가 바뀔 때마다 항상 render()가 호출된다.
            // ================================================================
            render() {
                const list = document.getElementById('todoList');
                // → <ul id="todoList"> DOM 요소

                const filteredTodos = this.getFilteredTodos();
                // 현재 필터에 맞는 할 일 배열을 가져온다

                if (filteredTodos.length === 0) {
                    list.innerHTML = '<li class="empty-message">할 일이 없습니다.</li>';
                    // 표시할 항목이 없으면 안내 메시지를 보여준다
                } else {
                    list.innerHTML = filteredTodos.map(todo => `
                        <li class="todo-item ${todo.completed ? 'completed' : ''}" data-id="${todo.id}">
                            <input type="checkbox" class="todo-checkbox" ${todo.completed ? 'checked' : ''}>
                            <span class="todo-text">${todo.text}</span>
                            <button class="delete-btn">삭제</button>
                        </li>
                    `).join('');
                    // ── 위 코드를 단계별로 분해하면: ──
                    //
                    // 1) filteredTodos.map(todo => `...`)
                    //    .map(): 배열의 각 요소를 변환해서 새 배열을 만든다
                    //    각 todo 객체를 → HTML 문자열로 변환
                    //    결과: ["<li>...</li>", "<li>...</li>", "<li>...</li>"]
                    //
                    // 2) 템플릿 리터럴 안의 삼항 연산자들:
                    //    ${todo.completed ? 'completed' : ''}
                    //    → completed가 true면 'completed' 클래스 추가 (취소선 스타일)
                    //    → false면 빈 문자열 (클래스 없음)
                    //
                    //    ${todo.completed ? 'checked' : ''}
                    //    → true면 체크박스에 checked 속성 추가
                    //
                    //    data-id="${todo.id}"
                    //    → 이벤트 위임에서 이 값을 읽어서 어떤 할 일인지 식별한다
                    //
                    // 3) .join('')
                    //    배열의 모든 문자열을 하나로 합친다
                    //    ["<li>A</li>", "<li>B</li>"] → "<li>A</li><li>B</li>"
                    //
                    // 4) list.innerHTML = ...
                    //    <ul> 안의 HTML을 통째로 교체한다
                }

                this.updateStats();
                // 통계도 함께 업데이트
            },


            // ================================================================
            // updateStats() - 하단 통계 텍스트 업데이트
            // ================================================================
            // 호출 흐름: render() → updateStats()
            // 역할: 전체/진행중/완료 개수를 계산해서 표시한다.
            // ================================================================
            updateStats() {
                const total = this.todos.length;
                // 전체 할 일 개수 (필터 무관, 원본 배열 기준)

                const completed = this.todos.filter(t => t.completed).length;
                // completed가 true인 항목의 개수
                // .filter()로 완료된 것만 모은 배열의 .length

                const active = total - completed;
                // 진행중 = 전체 - 완료

                document.getElementById('stats').textContent =
                    `전체: ${total}개 | 진행중: ${active}개 | 완료: ${completed}개`;
                // 예: "전체: 5개 | 진행중: 3개 | 완료: 2개"
            }
        };


        // ================================================================
        // 앱 시작!
        // ================================================================
        // HTML 파싱이 여기까지 도달하면 todoApp.init()이 실행된다.
        // init() → bindEvents() → 이벤트 리스너 등록 완료
        // 이후 사용자가 버튼을 클릭하면 등록된 콜백이 실행된다.
        //
        // 전체 실행 흐름 요약:
        //   1. todoApp.init() → bindEvents()로 이벤트 등록
        //   2. 사용자가 ID 입력 후 접속 → login() → fetchTodos() → render()
        //   3. 할 일 추가 → addTodo() → 서버에 POST → todos.push() → render()
        //   4. 체크박스 클릭 → toggleTodo() → 서버에 PATCH → todo.completed 변경 → render()
        //   5. 삭제 버튼 → deleteTodo() → 서버에 DELETE → todos에서 filter() → render()
        //   6. 필터 클릭 → setFilter() → render() → getFilteredTodos()로 표시 항목 결정
        //
        // 핵심 패턴: 모든 데이터 변경은 "서버 먼저 → 로컬 배열 갱신 → render()"로 이어진다.
        // ================================================================
        todoApp.init();
    </script>
</body>
</html>
